name: Build

on:
  push:
    branches: [main, uat, release*]
  workflow_dispatch:
    inputs:
      target:
        description: "Which worker config to deploy?"
        required: true
        type: choice
        options:
          - dgcs
          - homx
          - ordi
          - private

jobs:
  deploy_all:
    name: Deploy all workers (on push)
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        config:
          - wrangler-dgcs.toml
          - wrangler-homx.toml
          - wrangler-ordi.toml
          - wrangler-private.toml
    env:
      # Pin tool versions to avoid upstream updates breaking CI
      WORKER_BUILD_VERSION: "0.7.4"
      WRANGLER_VERSION: "4.54.0"
      BW_WEB_VERSION: ${{ vars.BW_WEB_VERSION || 'v2025.12.0' }}

      # Required for wrangler
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js (for npx wrangler)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Rust toolchain (from rust-toolchain.toml)
        run: |
          set -euo pipefail
          TOOLCHAIN="$(sed -n 's/^channel[[:space:]]*=[[:space:]]*"\([^"]*\)".*$/\1/p' rust-toolchain.toml | head -n 1)"
          if [ -z "$TOOLCHAIN" ]; then
            echo "‚ùå Failed to read toolchain channel from rust-toolchain.toml" >&2
            exit 1
          fi
          echo "Using Rust toolchain: $TOOLCHAIN"
          echo "RUSTUP_TOOLCHAIN=$TOOLCHAIN" >> "$GITHUB_ENV"
          rustup toolchain install "$TOOLCHAIN" --profile minimal --component rustfmt --component clippy --target wasm32-unknown-unknown

      - name: Install lld
        run: sudo apt install -y lld clang gcc llvm

      - name: Install worker-build
        run: |
          set -euo pipefail
          if command -v worker-build &> /dev/null; then
            echo "worker-build already installed: $(worker-build --version || true)"
          fi
          cargo install --locked -q worker-build --version "${WORKER_BUILD_VERSION}"

      - name: Download and extract frontend (bw_web_builds)
        run: |
          set -euo pipefail
          TAG="${BW_WEB_VERSION}"
          if [ "${TAG}" = "latest" ]; then
            TAG="$(curl -s https://api.github.com/repos/dani-garcia/bw_web_builds/releases/latest | jq -r .tag_name)"
          fi
          echo "üì¶ Downloading frontend version: ${TAG}"
          wget -q "https://github.com/dani-garcia/bw_web_builds/releases/download/${TAG}/bw_web_${TAG}.tar.gz"
          tar -xzf "bw_web_${TAG}.tar.gz" -C public/
          if [ ! -d "public/web-vault" ]; then
            echo "‚ùå Expected ./public/web-vault after extracting bw_web_builds" >&2
            ls -la public/ | head -50 || true
            exit 1
          fi
          find public/web-vault -type f -name '*.map' -delete
          rm -f "bw_web_${TAG}.tar.gz"
          echo "‚úÖ Frontend files extracted to ./public/web-vault"
          ls -la public/web-vault/ | head -20

      - name: Apply web vault overrides (vaultwarden.css)
        run: |
          bash scripts/apply-web-vault-overrides.sh public/web-vault

      - name: Replace D1_DATABASE_ID placeholders in selected wrangler config
        run: |
          set -euo pipefail
          CFG="${{ matrix.config }}"
          case "$CFG" in
            wrangler-dgcs.toml)   sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_DGCS }}/g" "$CFG" ;;
            wrangler-homx.toml)   sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_HOMX }}/g" "$CFG" ;;
            wrangler-ordi.toml)   sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_ORDI }}/g" "$CFG" ;;
            wrangler-private.toml) sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_PRIVATE }}/g" "$CFG" ;;
            *) echo "Unknown config: $CFG"; exit 1 ;;
          esac

      - name: Enable R2 binding when R2_NAME is provided
        env:
          R2_NAME: ${{ secrets.R2_NAME }}
        run: |
          set -euo pipefail
          CFG="${{ matrix.config }}"
          if [ -n "$R2_NAME" ]; then
            echo "üîß Enabling R2 bucket binding"
            {
              echo ''
              echo '[[r2_buckets]]'
              echo 'binding = "ATTACHMENTS_BUCKET"'
              echo "bucket_name = \"${R2_NAME}\""
            } >> "$CFG"
          else
            echo "‚è≠Ô∏è R2_NAME not set, skipping R2 binding"
          fi

      - name: Bootstrap D1 schema when database is empty
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"
          CFG="${{ matrix.config }}"
          set +e
          D1_OUT="$($WRANGLER d1 execute vault1 --remote --config "$CFG" --command \
            "SELECT COUNT(*) AS cnt FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '_cf_%' AND name NOT IN ('d1_migrations');" \
            --json 2>&1)"
          D1_STATUS=$?
          set -e
          if [ $D1_STATUS -ne 0 ]; then
            echo "‚ùå wrangler d1 execute failed (exit=$D1_STATUS). Raw output:"
            echo "$D1_OUT"
            exit $D1_STATUS
          fi
          TABLE_COUNT="$(printf '%s' "$D1_OUT" | jq -er 'if type=="array" and (length>0) and (.[0].results|type=="array") and (.[0].results|length>0) then (.[0].results[0].cnt // 0) else error("unexpected JSON shape") end' 2>/dev/null || true)"
          if [ -z "${TABLE_COUNT}" ]; then
            echo "‚ùå Unexpected JSON from wrangler (cannot extract table count). Raw output:"
            echo "$D1_OUT"
            exit 1
          fi
          echo "Existing app table count: ${TABLE_COUNT}"
          if [ "${TABLE_COUNT}" = "0" ]; then
            echo "üÜï Empty D1 database detected; applying sql/schema.sql..."
            $WRANGLER d1 execute vault1 --remote --config "$CFG" --file sql/schema.sql
            echo "üìù Marking existing migrations as applied (schema.sql already includes them)"
            BOOTSTRAP_SQL="$(mktemp)"
            cat >"${BOOTSTRAP_SQL}" <<'SQL'
CREATE TABLE IF NOT EXISTS d1_migrations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT UNIQUE NOT NULL,
  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
SQL
            shopt -s nullglob
            for f in migrations/*.sql; do
              echo "INSERT OR IGNORE INTO d1_migrations (name) VALUES ('$(basename "${f}")');" >>"${BOOTSTRAP_SQL}"
            done
            $WRANGLER d1 execute vault1 --remote --config "$CFG" --file "${BOOTSTRAP_SQL}"
            rm -f "${BOOTSTRAP_SQL}"
          else
            echo "‚è≠Ô∏è D1 already has tables; skipping base schema bootstrap"
          fi

      - name: Apply D1 database migrations
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"
          CFG="${{ matrix.config }}"
          MAX_RETRIES=10
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "üîÑ Attempting to apply migrations (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            if $WRANGLER d1 migrations apply vault1 --remote --config "$CFG" 2>&1 | tee migration_output.txt; then
              echo "‚úÖ All migrations applied successfully"
              exit 0
            fi
            if grep -q "duplicate column name" migration_output.txt; then
              FAILED_MIGRATION=$(grep -oP "Migration \\K[0-9]+_[a-zA-Z0-9_]+\\.sql(?= failed)" migration_output.txt)
              if [ -z "$FAILED_MIGRATION" ]; then
                echo "‚ùå Detected duplicate column error, but could not identify the migration filename from output."
                cat migration_output.txt
                exit 1
              fi
              echo "‚ö†Ô∏è Migration '$FAILED_MIGRATION' failed: column already exists"
              echo "üìù Marking migration as applied..."
              $WRANGLER d1 execute vault1 --remote --config "$CFG" --command "
                CREATE TABLE IF NOT EXISTS d1_migrations (
                  id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT UNIQUE NOT NULL,
                  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
                );
                INSERT OR IGNORE INTO d1_migrations (name) VALUES ('$FAILED_MIGRATION');
              "
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "üîÅ Retrying remaining migrations..."
            else
              echo "‚ùå Migration failed with unexpected error:"
              cat migration_output.txt
              exit 1
            fi
          done
          echo "‚ùå Max retries ($MAX_RETRIES) exceeded"
          exit 1

      - name: Seed global equivalent domains (optional)
        env:
          SEED_GLOBAL_DOMAINS: ${{ vars.SEED_GLOBAL_DOMAINS || 'true' }}
          GLOBAL_DOMAINS_URL: ${{ vars.GLOBAL_DOMAINS_URL }}
        run: |
          set -euo pipefail
          CFG="${{ matrix.config }}"
          if [ "${SEED_GLOBAL_DOMAINS}" = "false" ]; then
            echo "‚è≠Ô∏è SEED_GLOBAL_DOMAINS=false, skipping"
            exit 0
          fi
          if [ -n "${GLOBAL_DOMAINS_URL:-}" ]; then
            bash scripts/seed-global-domains.sh --db vault1 --remote --wrangler-version "${WRANGLER_VERSION}" --url "${GLOBAL_DOMAINS_URL}" --config "$CFG"
          else
            bash scripts/seed-global-domains.sh --db vault1 --remote --wrangler-version "${WRANGLER_VERSION}" --config "$CFG"
          fi

      - uses: cloudflare/wrangler-action@v3
        id: cf
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: ${{ env.WRANGLER_VERSION }}
          packageManager: npm
          command: deploy --config ${{ matrix.config }}

  deploy_one:
    name: Deploy one worker (manual)
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    env:
      WORKER_BUILD_VERSION: "0.7.4"
      WRANGLER_VERSION: "4.54.0"
      BW_WEB_VERSION: ${{ vars.BW_WEB_VERSION || 'v2025.12.0' }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js (for npx wrangler)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Resolve config file from input
        id: cfg
        run: |
          set -euo pipefail
          case "${{ inputs.target }}" in
            dgcs)    echo "CFG=wrangler-dgcs.toml" >> "$GITHUB_OUTPUT" ;;
            homx)    echo "CFG=wrangler-homx.toml" >> "$GITHUB_OUTPUT" ;;
            ordi)    echo "CFG=wrangler-ordi.toml" >> "$GITHUB_OUTPUT" ;;
            private) echo "CFG=wrangler-private.toml" >> "$GITHUB_OUTPUT" ;;
            *) echo "Unknown target: ${{ inputs.target }}"; exit 1 ;;
          esac

      - name: Install Rust toolchain (from rust-toolchain.toml)
        run: |
          set -euo pipefail
          TOOLCHAIN="$(sed -n 's/^channel[[:space:]]*=[[:space:]]*"\([^"]*\)".*$/\1/p' rust-toolchain.toml | head -n 1)"
          if [ -z "$TOOLCHAIN" ]; then
            echo "‚ùå Failed to read toolchain channel from rust-toolchain.toml" >&2
            exit 1
          fi
          echo "Using Rust toolchain: $TOOLCHAIN"
          echo "RUSTUP_TOOLCHAIN=$TOOLCHAIN" >> "$GITHUB_ENV"
          rustup toolchain install "$TOOLCHAIN" --profile minimal --component rustfmt --component clippy --target wasm32-unknown-unknown

      - name: Install lld
        run: sudo apt install -y lld clang gcc llvm

      - name: Install worker-build
        run: |
          set -euo pipefail
          if command -v worker-build &> /dev/null; then
            echo "worker-build already installed: $(worker-build --version || true)"
          fi
          cargo install --locked -q worker-build --version "${WORKER_BUILD_VERSION}"

      - name: Download and extract frontend (bw_web_builds)
        run: |
          set -euo pipefail
          TAG="${BW_WEB_VERSION}"
          if [ "${TAG}" = "latest" ]; then
            TAG="$(curl -s https://api.github.com/repos/dani-garcia/bw_web_builds/releases/latest | jq -r .tag_name)"
          fi
          echo "üì¶ Downloading frontend version: ${TAG}"
          wget -q "https://github.com/dani-garcia/bw_web_builds/releases/download/${TAG}/bw_web_${TAG}.tar.gz"
          tar -xzf "bw_web_${TAG}.tar.gz" -C public/
          if [ ! -d "public/web-vault" ]; then
            echo "‚ùå Expected ./public/web-vault after extracting bw_web_builds" >&2
            ls -la public/ | head -50 || true
            exit 1
          fi
          find public/web-vault -type f -name '*.map' -delete
          rm -f "bw_web_${TAG}.tar.gz"
          echo "‚úÖ Frontend files extracted to ./public/web-vault"
          ls -la public/web-vault/ | head -20

      - name: Apply web vault overrides (vaultwarden.css)
        run: |
          bash scripts/apply-web-vault-overrides.sh public/web-vault

      - name: Replace D1_DATABASE_ID placeholders in selected wrangler config
        run: |
          set -euo pipefail
          CFG="${{ steps.cfg.outputs.CFG }}"
          case "$CFG" in
            wrangler-dgcs.toml)   sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_DGCS }}/g" "$CFG" ;;
            wrangler-homx.toml)   sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_HOMX }}/g" "$CFG" ;;
            wrangler-ordi.toml)   sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_ORDI }}/g" "$CFG" ;;
            wrangler-private.toml) sed -i "s/\${D1_DATABASE_ID}/\${{ secrets.D1_DATABASE_ID_PRIVATE }}/g" "$CFG" ;;
            *) echo "Unknown config: $CFG"; exit 1 ;;
          esac

      - name: Enable R2 binding when R2_NAME is provided
        env:
          R2_NAME: ${{ secrets.R2_NAME }}
        run: |
          set -euo pipefail
          CFG="${{ steps.cfg.outputs.CFG }}"
          if [ -n "$R2_NAME" ]; then
            echo "üîß Enabling R2 bucket binding"
            {
              echo ''
              echo '[[r2_buckets]]'
              echo 'binding = "ATTACHMENTS_BUCKET"'
              echo "bucket_name = \"${R2_NAME}\""
            } >> "$CFG"
          else
            echo "‚è≠Ô∏è R2_NAME not set, skipping R2 binding"
          fi

      - name: Bootstrap D1 schema when database is empty
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"
          CFG="${{ steps.cfg.outputs.CFG }}"
          set +e
          D1_OUT="$($WRANGLER d1 execute vault1 --remote --config "$CFG" --command \
            "SELECT COUNT(*) AS cnt FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '_cf_%' AND name NOT IN ('d1_migrations');" \
            --json 2>&1)"
          D1_STATUS=$?
          set -e
          if [ $D1_STATUS -ne 0 ]; then
            echo "‚ùå wrangler d1 execute failed (exit=$D1_STATUS). Raw output:"
            echo "$D1_OUT"
            exit $D1_STATUS
          fi
          TABLE_COUNT="$(printf '%s' "$D1_OUT" | jq -er 'if type=="array" and (length>0) and (.[0].results|type=="array") and (.[0].results|length>0) then (.[0].results[0].cnt // 0) else error("unexpected JSON shape") end' 2>/dev/null || true)"
          if [ -z "${TABLE_COUNT}" ]; then
            echo "‚ùå Unexpected JSON from wrangler (cannot extract table count). Raw output:"
            echo "$D1_OUT"
            exit 1
          fi
          echo "Existing app table count: ${TABLE_COUNT}"
          if [ "${TABLE_COUNT}" = "0" ]; then
            echo "üÜï Empty D1 database detected; applying sql/schema.sql..."
            $WRANGLER d1 execute vault1 --remote --config "$CFG" --file sql/schema.sql
            echo "üìù Marking existing migrations as applied (schema.sql already includes them)"
            BOOTSTRAP_SQL="$(mktemp)"
            cat >"${BOOTSTRAP_SQL}" <<'SQL'
CREATE TABLE IF NOT EXISTS d1_migrations (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT UNIQUE NOT NULL,
  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);
SQL
            shopt -s nullglob
            for f in migrations/*.sql; do
              echo "INSERT OR IGNORE INTO d1_migrations (name) VALUES ('$(basename "${f}")');" >>"${BOOTSTRAP_SQL}"
            done
            $WRANGLER d1 execute vault1 --remote --config "$CFG" --file "${BOOTSTRAP_SQL}"
            rm -f "${BOOTSTRAP_SQL}"
          else
            echo "‚è≠Ô∏è D1 already has tables; skipping base schema bootstrap"
          fi

      - name: Apply D1 database migrations
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"
          CFG="${{ steps.cfg.outputs.CFG }}"
          MAX_RETRIES=10
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "üîÑ Attempting to apply migrations (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            if $WRANGLER d1 migrations apply vault1 --remote --config "$CFG" 2>&1 | tee migration_output.txt; then
              echo "‚úÖ All migrations applied successfully"
              exit 0
            fi
            if grep -q "duplicate column name" migration_output.txt; then
              FAILED_MIGRATION=$(grep -oP "Migration \\K[0-9]+_[a-zA-Z0-9_]+\\.sql(?= failed)" migration_output.txt)
              if [ -z "$FAILED_MIGRATION" ]; then
                echo "‚ùå Detected duplicate column error, but could not identify the migration filename from output."
                cat migration_output.txt
                exit 1
              fi
              echo "‚ö†Ô∏è Migration '$FAILED_MIGRATION' failed: column already exists"
              echo "üìù Marking migration as applied..."
              $WRANGLER d1 execute vault1 --remote --config "$CFG" --command "
                CREATE TABLE IF NOT EXISTS d1_migrations (
                  id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT UNIQUE NOT NULL,
                  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
                );
                INSERT OR IGNORE INTO d1_migrations (name) VALUES ('$FAILED_MIGRATION');
              "
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "üîÅ Retrying remaining migrations..."
            else
              echo "‚ùå Migration failed with unexpected error:"
              cat migration_output.txt
              exit 1
            fi
          done
          echo "‚ùå Max retries ($MAX_RETRIES) exceeded"
          exit 1

      - name: Seed global equivalent domains (optional)
        env:
          SEED_GLOBAL_DOMAINS: ${{ vars.SEED_GLOBAL_DOMAINS || 'true' }}
          GLOBAL_DOMAINS_URL: ${{ vars.GLOBAL_DOMAINS_URL }}
        run: |
          set -euo pipefail
          CFG="${{ steps.cfg.outputs.CFG }}"
          if [ "${SEED_GLOBAL_DOMAINS}" = "false" ]; then
            echo "‚è≠Ô∏è SEED_GLOBAL_DOMAINS=false, skipping"
            exit 0
          fi
          if [ -n "${GLOBAL_DOMAINS_URL:-}" ]; then
            bash scripts/seed-global-domains.sh --db vault1 --remote --wrangler-version "${WRANGLER_VERSION}" --url "${GLOBAL_DOMAINS_URL}" --config "$CFG"
          else
            bash scripts/seed-global-domains.sh --db vault1 --remote --wrangler-version "${WRANGLER_VERSION}" --config "$CFG"
          fi

      - uses: cloudflare/wrangler-action@v3
        id: cf
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: ${{ env.WRANGLER_VERSION }}
          packageManager: npm
          command: deploy --config ${{ steps.cfg.outputs.CFG }}
